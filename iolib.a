#include <comp421/filesystem.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <comp421/iolib.h>
#include <comp421/hardware.h>

int Link(char *oldname, char *newname);
int Unlink(char *pathname);
int SymLink(char *oldname, char *newname);
int ReadLink(char *pathname, char *buf, int len);
int MkDir(char *pathname);
int RmDir(char *pathname);
int ChDir(char *pathname);
int Stat(char *pathname, struct Stat *statbuf);
int Sync(void);
int Shutdown(void);

struct inode open_files[MAX_OPEN_FILES];

struct node_list {
    struct file_tree *first;
    struct node_list *rest;
}

struct file_tree {
    struct inode *cur;
    struct file_tree *parent;
    struct node_list *children;
    char *name;
}

int 
Link(char *oldname, char *newname) 
{

}
int 
Unlink(char *pathname) 
{

}
int SymLink
(char *oldname, char *newname) 
{
    return 0;
}
int 
ReadLink
(char *pathname, char *buf, int len) 
{

}
int 
MkDir(char *pathname) 
{

}
int 
RmDir(char *pathname) 
{

}
int 
ChDir(char *pathname) 
{

}
int 
Stat(char *pathname, struct Stat *statbuf) 
{

}
int 
Sync(void) 
{

}
int 
Shutdown(void) 
{

}

void
InsertNode(struct node_list **wait, struct inode *node, struct file_tree *parent, char *name)
{
	struct file_tree *new = malloc(sizeof(struct file_tree));
  
	new->cur = node;
	new->name = name;
	new->parent = parent;
    new->children = NULL;

	struct node_list *new_node = malloc(sizeof(struct node_list));
	new_node->first = new;
	new_node->rest = NULL;

    struct node_list *list = *wait;
    TracePrintf(0, "InsertNode: Outside loop 1\n");
    while (list->rest != NULL) {
        list = list->rest;
    }
    TracePrintf(0, "InsertNode: Outside loop 2\n");

    list->rest = new_node;
}

int
RemoveWaitingList(struct node_list **wait, struct inode node)
{
	struct node_list *q = (*wait)->rest;
	struct node_list *prev;
	if (q != NULL && q->first->cur == node) {
		(*wait)->rest = q->rest;
		free(q);
		return (0);
	}
	while (q != NULL && q->first->cur != node){
		prev = q;
		q = q->rest;
	}

	if (q == NULL) {
		return (-1);
	}
	
	prev->rest = q->rest;
	free(q);
	return(0);
}